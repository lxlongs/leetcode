package medium

/*
1223. 掷骰子模拟

有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。
不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。
现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。

示例 1：
输入：n = 2, rollMax = [1,1,2,2,2,3]
输出：34
解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。

示例 2：
输入：n = 2, rollMax = [1,1,1,1,1,1]
输出：30

示例 3：
输入：n = 3, rollMax = [1,1,1,2,2,3]
输出：181

提示：
1 <= n <= 5000
rollMax.length == 6
1 <= rollMax[i] <= 15
*/

func dieSimulator(n int, rollMax []int) int {
	mod := 1000000007
	dp := [6][15]int{}
	total := [6]int{}
	for i := 0; i < 6; i++ {
		dp[i][0] = 1
		total[i] = 1
	}
	for n > 1 {
		tmp := [6][15]int{}
		for i := 0; i < 6; i++ {
			for j := 0; j < 6; j++ {
				if i != j {
					tmp[i][0] = (tmp[i][0] + total[j]) % mod
				}
			}
			for j := 1; j < rollMax[i]; j++ {
				tmp[i][j] = dp[i][j-1]
			}
		}

		dp = tmp
		for i := 0; i < 6; i++ {
			total[i] = 0
			for j := 0; j < rollMax[i]; j++ {
				total[i] = (total[i] + dp[i][j]) % mod
			}
		}
		n--
	}
	ret := 0
	for i := 0; i < 6; i++ {
		ret = (ret + total[i]) % mod
	}
	return ret
}

/*
统计每个回合每个数字的连续次数，最后计算总和。

先来一张图，方便理解：
这里 dp[2][1][0] = sum(dp[1][2]) + sum(dp[1][3]) + sum(dp[1][4]) + sum(dp[1][5]) + sum(dp[1][6]) = 5，线太多影响体验就没有画。

我们通过一个二维数据 dp[6][15] 统计每一轮每个数字的连续情况。dp[3][4] 表示点数 3 连续 4 次的数字个数。

首先，当 n=1 时，所有数字都是一样，且连续次数都是 1。
当 n=2 时，就需要根据 rollMax 去计算。
连续次数为 1 的时候很好理解，就是把其他点数当前的点数全部相加即可，对应代码为：
Go
for j := 0; j < 6; j++ {
	if i != j {
		tmp[i][0] = (tmp[i][0] + total[j]) % mod
	}
}
连续次数为 时，只能取上一次连续次数为 1 的值，其他情况均不满足，对应代码为：
Go
for j := 1; j < rollMax[i]; j++ { // 根据rollMax判断可以连续几次
	tmp[i][j] = dp[i][j-1]
}
计算当次每个点数总和，方便下次计算。
累加最后一次计算的总和。

*/
